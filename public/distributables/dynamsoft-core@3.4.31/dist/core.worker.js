/*!
 * Dynamsoft JavaScript Library
 * @product Dynamsoft Core JS Edition
 * @website https://www.dynamsoft.com
 * @copyright Copyright 2024, Dynamsoft Corporation
 * @author Dynamsoft
 * @version 3.4.31
 * @fileoverview Dynamsoft JavaScript Library for Core
 * More info on Dynamsoft Core JS: https://www.dynamsoft.com/capture-vision/docs/web/programming/javascript/api-reference/core/core-module.html
 */
!function(){"use strict";const e=e=>e&&"object"==typeof e&&"function"==typeof e.then,t=(async()=>{})().constructor;class s extends t{get status(){return this._s}get isPending(){return"pending"===this._s}get isFulfilled(){return"fulfilled"===this._s}get isRejected(){return"rejected"===this._s}get task(){return this._task}set task(s){let r;this._task=s,e(s)?r=s:"function"==typeof s&&(r=new t(s)),r&&(async()=>{try{const e=await r;s===this._task&&this.resolve(e)}catch(e){s===this._task&&this.reject(e)}})()}get isEmpty(){return null==this._task}constructor(t){let s,r;super(((e,t)=>{s=e,r=t})),this._s="pending",this.resolve=t=>{this.isPending&&(e(t)?this.task=t:(this._s="fulfilled",s(t)))},this.reject=e=>{this.isPending&&(this._s="rejected",r(e))},this.task=t}}const r=self,o={};r.coreWorkerVersion="3.4.31",r.versions=o;const a={},n=r.waitAsyncDependency=async e=>{let t="string"==typeof e?[e]:e,r=[];for(let e of t)r.push(a[e]=a[e]||new s);await Promise.all(r)},i=async(e,t)=>{let r,o="string"==typeof e?[e]:e,n=[];for(let e of o){let o;n.push(o=a[e]=a[e]||new s(r=r||t())),o.isEmpty&&(o.task=r=r||t())}await Promise.all(n)},l=[];r.setBufferIntoWasm=(e,t=0,s=0,r=0)=>{s&&(e=r?e.subarray(s,r):e.subarray(s));let o=l[t]=l[t]||{ptr:0,size:0,maxSize:0};return e.length>o.maxSize&&(o.ptr&&m._free(o.ptr),o.ptr=m._malloc(e.length),o.maxSize=e.length),m.HEAPU8.set(e,o.ptr),o.size=e.length,o.ptr};const c={buffer:0,size:0,pos:0,temps:[],needed:0,prepare:function(){if(c.needed){for(let e=0;e<c.temps.length;e++)m._free(c.temps[e]);c.temps.length=0,m._free(c.buffer),c.buffer=0,c.size+=c.needed,c.needed=0}c.buffer||(c.size+=128,c.buffer=m._malloc(c.size),assert(c.buffer)),c.pos=0},alloc:function(e,t){assert(c.buffer);let s,r=t.BYTES_PER_ELEMENT,o=e.length*r;return o=o+7&-8,c.pos+o>=c.size?(assert(o>0),c.needed+=o,s=m._malloc(o),c.temps.push(s)):(s=c.buffer+c.pos,c.pos+=o),s},copy:function(e,t,s){switch(s>>>=0,t.BYTES_PER_ELEMENT){case 2:s>>>=1;break;case 4:s>>>=2;break;case 8:s>>>=3}for(let r=0;r<e.length;r++)t[s+r]=e[r]}},d=r.ep=c.prepare;r.bDebug=!1,r.bLog=!1,r.strDomain=void 0;const p=r.es=e=>{let t=intArrayFromString(e),s=c.alloc(t,m.HEAP8);return c.copy(t,m.HEAP8,s),s},m=r.Module={print:e=>{r.bLog&&y(e)},printErr:e=>{r.bLog&&y(e)},locateFile:(e,t)=>{if(["std.wasm","core.wasm"].includes(e)){return u[e.split(".")[0]]+e}return e}},u=r.engineResourcePaths={},f=r.loadCore=async()=>{const e="core";await i(e,(async()=>{let t=r.bLog&&(y(e+" loading..."),Date.now())||0,s=new Promise((s=>{m.onRuntimeInitialized=()=>{r.bLog&&y(e+" initialized, cost "+(Date.now()-t)+" ms"),s(void 0)}})),o=u.std+"std.js";importScripts(o),await s}))},g=r.loadSideModule=async(e,{js:t,wasm:s})=>{await i(e,(async()=>{await n("core");let a=r.bLog&&(y(e+" loading..."),Date.now())||0;if(t instanceof Array)for(let s of t){let t=u[e]+s;importScripts(t)}else if(t){let t=u[e]+e+".worker.js";importScripts(t)}if(s instanceof Array)for(let t of s){let s=u[e]+t;try{await loadDynamicLibrary(s,{loadAsync:!0,global:!0,nodelete:!0,allowUndefined:!0})}catch(e){throw e}}else if(s){let t=u[e]+e+".wasm";try{await loadDynamicLibrary(t,{loadAsync:!0,global:!0,nodelete:!0,allowUndefined:!0})}catch(e){throw e}}wasmImports.emscripten_bind_CoreWasm_PreSetModuleExist&&(d(),wasmImports.emscripten_bind_CoreWasm_PreSetModuleExist(p(e.toUpperCase()))),wasmImports.emscripten_bind_CvrWasm_SetModuleExist&&(d(),wasmImports.emscripten_bind_CvrWasm_SetModuleExist(p(e.toUpperCase())));const i=JSON.parse(UTF8ToString(wasmImports.emscripten_bind_CoreWasm_GetModuleVersion_0())),l=r[`${e}WorkerVersion`];o[e]={worker:`${l||"No Worker"}`,wasm:i[e.toUpperCase()]},r.bLog&&y(e+" initialized, cost "+(Date.now()-a)+" ms")}))},_=r.mapController={loadWasm:async(e,t)=>{try{Object.assign(u,e.engineResourcePaths),e.needLoadCore&&(e.bLog&&(r.bLog=!0),e.dm&&(r.strDomain=e.dm),e.bd&&(r.bDebug=!0),await f());for(let t of e.names)await g(t,e.autoResources[t]);if(e.needLoadCore){const e=JSON.parse(UTF8ToString(wasmImports.emscripten_bind_CoreWasm_GetModuleVersion_0()));o.core={worker:r.coreWorkerVersion,wasm:e.CORE}}b(t,{versions:o})}catch(e){console.log(e),h(t,e)}},setBLog:e=>{r.bLog=e.value},setBDebug:e=>{r.bDebug=e.value},getModuleVersion:async(e,t)=>{try{let e=UTF8ToString(wasmImports.emscripten_bind_CoreWasm_GetModuleVersion_0());b(t,{versions:JSON.parse(e)})}catch(e){h(t,e)}},cfd:async(e,t)=>{try{wasmImports.emscripten_bind_CoreWasm_static_CFD_1(e.count),b(t,{})}catch(e){h(t,e)}}};addEventListener("message",(e=>{const t=e.data?e.data:e,s=t.body,r=t.id,o=t.instanceID,a=_[t.type];if(!a)throw new Error("Unmatched task: "+t.type);a(s,r,o)}));const b=r.handleTaskRes=(e,t)=>{postMessage({type:"task",id:e,body:Object.assign({success:!0},t)})},h=r.handleTaskErr=(e,t)=>{postMessage({type:"task",id:e,body:{success:!1,message:(null==t?void 0:t.message)||"No have error message.",stack:r.bDebug&&(null==t?void 0:t.stack)||"No have stack."}})},y=r.log=e=>{postMessage({type:"log",message:e})}}();
